# -*- coding: utf-8 -*-
"""Summary_13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gri757vQAxQh9eZFNEqBvJAqQ-SeU5Yn

## Python Fundamentals 2025: Домашнее задание 24

### 1. Сумма цифр числа

Напишите рекурсивную функцию, которая находит сумму всех цифр числа.

Данные:

num = 43197

Пример вывода:

24
"""

def digit_sum(n):
    if n == 0:
        return 0
    return n % 10 + digit_sum(n // 10)


num = 43197
print(digit_sum(num))

def digit_sum(n):
    if n == 0:
        return 0
    number = n % 10
    another_nums = digit_sum(n // 10)
    result = number + another_nums
    return result


num = 43197
print(digit_sum(num))

num = -43197.5

def sum_nummers_nummer_rec(f: float) -> int:
    s = str(abs(f)).replace(".", "")
    if len(s) == 2:
        return int(s)
    return int(s[0]) + sum_nummers_nummer_rec(float(s[1:]))
print("recursive", sum_nummers_nummer_rec(num))

"""### 2. Сумма вложенных чисел

Напишите рекурсивную функцию, которая суммирует все числа во вложенных списках.

Данные:

nested_numbers = [1, [2, 3], [4, [5, 6]], 7]

Пример вывода:

28
"""

def deep_sum(nested_list):
    total = 0
    for item in nested_list:
        if isinstance(item, list):
            total += deep_sum(item)
        else:
            total += item
    return total


nested_numbers = [1, [2, 3], [4, [5, 6]], 7]
print(deep_sum(nested_numbers))

"""## Python Fundamentals 2025: Домашнее задание 25

### 1. Деление без ошибок

Напишите функцию, которая выполняет деление двух чисел, введенных пользователем, и обрабатывает возможные ошибки.

Пример вывода:

Введите делимое: 345

Введите делитель: 5a

Ошибка: Введено некорректное число.
"""

def safe_divide():
    try:
        num1 = float(input("Введите делимое: "))
        num2 = float(input("Введите делитель: "))
        return num1 / num2
    except ValueError:
        print("Ошибка: Введено некорректное число.")
    except ZeroDivisionError:
        print("Ошибка: Деление на ноль невозможно.")

result = safe_divide()
if result is not None:
    print(f"Результат: {result}")

"""### 2. Логирование ошибок

Перенаправьте в предыдущей задаче вывод ошибок в файл errors.log в соответствии с форматом ниже.

Пример вывода:

2025-02-23 22:38:53,686 - ERROR - test.py - 16 - Ошибка: Введено некорректное число.
"""

import logging

logging.basicConfig( # filename="errors.log",
                    level=logging.ERROR,
                    format="%(asctime)s - %(levelname)s - %(filename)s - %(lineno)d - %(message)s")


def safe_divide():
    try:
        num1 = float(input("Введите делимое: "))
        num2 = float(input("Введите делитель: "))
        return num1 / num2
    except ZeroDivisionError:
        logging.error("Ошибка: Деление на ноль невозможно.")
    except ValueError:
        logging.error("Ошибка: Введено некорректное число.")

result = safe_divide()
if result is not None:
    print(f"Результат: {result}")

"""# Extra

3. **Глубина вложенности списка**

Напишите рекурсивную функцию, которая определяет максимальную глубину вложенности списка.
Функция должна проверять:  
- Аргумент должен быть списком.  
- Вложенные структуры, если они есть, также должны быть списками.  
Если данные не валидны необходимо выбрасывать исключение. При вызове функции обработайте возможное исключение.


**Данные:**  
```python
nested_list = [1, [2, [3, [4, [5]]]], 6, [[7, 8], 9]]
```

**Пример вывода:**  
```
Максимальная глубина: 5
```
"""

def max_depth(data):
    if not isinstance(data, list):
        raise TypeError("Ожидается вложенный список.")
    depth = [max_depth(item) for item in data if isinstance(item, list)]
    return 1 + max(depth, default=0)

try:
    nested_list = [1, [2, [3, [4, [5]]]], 6, [[7, 8], 9]]
    print("Максимальная глубина:", max_depth(nested_list))
except TypeError as e:
    print("Ошибка:", e)

"""4. **Сумма продаж**

Есть дерево подразделений внутри компании (каждое подразделение может содержать «дочерние» отделы).
Напишите рекурсивную функцию, которая подсчитывает суммарные продажи для всех отделов.
Функция должна проверять:  
- Аргумент должен быть словарем.  
- Дочерние отделы (если есть) должны быть списком словарей.  
Если данные не валидны необходимо выбрасывать исключение. При вызове функции обработайте возможное исключение.


**Данные:**  
```python
company_structure = {
    "dept_name": "Head Office",
    "sales": 100,
    "sub_departments": [
        {
            "dept_name": "Sales Department",
            "sales": 200,
            "sub_departments": [
                {
                    "dept_name": "B2B Sales",
                    "sales": 120,
                }
            ]
        },
        {
            "dept_name": "IT Department",
            "sales": 150,
            "sub_departments": [
                {
                    "dept_name": "DevOps",
                    "sales": 300,
                    "sub_departments": [
                        {
                            "dept_name": "Cloud Infrastructure",
                            "sales": 180,
                        }
                    ]
                },
                {
                    "dept_name": "QA Department",
                    "sales": 90,
                }
            ]
        }
    ]
}
```

**Пример вывода:**  
```
Общая сумма продаж: 1140
```


"""

def summarize_sales(department, sales_name):
    if not isinstance(department, dict):
        raise TypeError("Ожидается словарь с информацией о департаменте.")
    total = department.get(sales_name, 0)
    for sub_dept in department.get("sub_departments", []):
        total += summarize_sales(sub_dept, sales_name)
    return total

company_structure = {
    "dept_name": "Head Office",
    "sales": 100,
    "sub_departments": [
        {
            "dept_name": "Sales Department",
            "sales": 200,
            "sub_departments": [
                {
                    "dept_name": "B2B Sales",
                    "sales": 120,
                }
            ]
        },
        {
            "dept_name": "IT Department",
            "sales": 150,
            "sub_departments": [
                {
                    "dept_name": "DevOps",
                    "sales": 300,
                    "sub_departments": [
                        {
                            "dept_name": "Cloud Infrastructure",
                            "sales": 180,
                        }
                    ]
                },
                {
                    "dept_name": "QA Department",
                    "sales": 90,
                }
            ]
        }
    ]
}
try:
    print(f"Общая сумма продаж: {summarize_sales(company_structure, "sales")}")
except TypeError as e:
    print("Ошибка:", e)

"""5. **Читабельный формат словаря**

Дан вложенный словарь. Напишите рекурсивную функцию, которая преобразует его в «плоский» формат,  
где в ключе будет содержаться полный путь к значению.  

**Данные:**  
```python
data = {
    "user": {
        "id": 123,
        "info": {
            "name": "Alice",
            "location": {
                "city": "Berlin",
                "coordinates": {"lat": 52.52, "lon": 13.405}
            },
            "hobby": ["swimming", "drawing"]
        }
    },
    "score": 95
}
```

**Пример вывода:**  
```
Данные для анализа:
user.id : 123
user.info.name : Alice
user.info.location.city : Berlin
user.info.location.coordinates.lat : 52.52
user.info.location.coordinates.lon : 13.405
user.info.hobby : ['swimming', 'drawing']
score : 95
```

"""

def parse_data(data, parent_key="", result=None):
    if result is None:
        result = {}

    if isinstance(data, dict):
        for key, value in data.items():
            new_key = f"{parent_key}.{key}" if parent_key else key
            parse_data(value, parent_key=new_key, result=result)
    else:
        result[parent_key] = data

    return result

data = {
    "user": {
        "id": 123,
        "info": {
            "name": "Alice",
            "location": {
                "city": "Berlin",
                "coordinates": {"lat": 52.52, "lon": 13.405}
            },
            "hobby": ["swimming", "drawing"]
        }
    },
    "score": 95
}

parsed_data = parse_data(data)
print("Данные для анализа:")
for k, v in parsed_data.items():
    print(k, ":", v)